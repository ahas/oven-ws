{"version":3,"sources":["urlencoded.js"],"names":["bytes","contentType","createError","dbg","read","typeis","typeChecker","debug","module","exports","urlencoded","parsers","Object","create","options","opts","inflate","limit","parse","type","verify","TypeError","parseQuery","getQueryParser","shouldParse","body","length","urlencodedParser","req","res","next","bodyParsed","hasBody","headers","charset","getCharset","toUpperCase","encoding","parser","parameterLimit","undefined","isNaN","isFinite","queryparse","paramCount","parameterCount","arrayLimit","Math","max","allowPrototypes","depth","Infinity","parameters","toLowerCase","e","count","index","indexOf","name","mod","require"],"mappings":"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","file":"urlencoded.js","sourcesContent":["import bytes from \"bytes\";\r\nimport contentType from \"content-type\";\r\nimport createError from \"http-errors\";\r\nimport dbg from \"debug\";\r\nimport read from \"../read\";\r\nimport typeis from \"type-is\";\r\nimport { typeChecker } from \"src/utils\";\r\nvar debug = dbg(\"body-parser:urlencoded\");\r\n/**\r\n * Module exports.\r\n */\r\nmodule.exports = urlencoded;\r\n/**\r\n * Cache of parser modules.\r\n */\r\nvar parsers = Object.create(null);\r\n/**\r\n * Create a middleware to parse urlencoded bodies.\r\n *\r\n * @param {object} [options]\r\n * @return {function}\r\n * @public\r\n */\r\nexport default function urlencoded(options) {\r\n    var opts = options || {};\r\n    var inflate = opts.inflate !== false;\r\n    var limit = typeof opts.limit !== \"number\" ? bytes.parse(opts.limit || \"100kb\") : opts.limit;\r\n    var type = opts.type || \"application/x-www-form-urlencoded\";\r\n    var verify = opts.verify || false;\r\n    if (verify !== false && typeof verify !== \"function\") {\r\n        throw new TypeError(\"option verify must be function\");\r\n    }\r\n    // create the appropriate query parser\r\n    var parseQuery = getQueryParser(opts);\r\n    // create the appropriate type checking function\r\n    var shouldParse = typeof type !== \"function\" ? typeChecker(type) : type;\r\n    function parse(body) {\r\n        return (body.length ? parseQuery(body) : {});\r\n    }\r\n    return function urlencodedParser(req, res, next) {\r\n        if (req.bodyParsed) {\r\n            debug(\"body already parsed\");\r\n            next();\r\n            return;\r\n        }\r\n        req.body = req.body || {};\r\n        // skip requests without bodies\r\n        if (!typeis.hasBody(req)) {\r\n            debug(\"skip empty body\");\r\n            next();\r\n            return;\r\n        }\r\n        debug(\"content-type %j\", req.headers[\"content-type\"]);\r\n        // determine if request should be parsed\r\n        if (!shouldParse(req)) {\r\n            debug(\"skip parsing\");\r\n            next();\r\n            return;\r\n        }\r\n        // assert charset\r\n        var charset = getCharset(req) || \"utf-8\";\r\n        if (charset !== \"utf-8\") {\r\n            debug(\"invalid charset\");\r\n            next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\r\n                charset: charset,\r\n                type: \"charset.unsupported\",\r\n            }));\r\n            return;\r\n        }\r\n        // read\r\n        read(req, res, next, parse, debug, {\r\n            encoding: charset,\r\n            inflate: inflate,\r\n            limit: limit,\r\n            verify: verify,\r\n        });\r\n    };\r\n}\r\n/**\r\n * Get the extended query parser.\r\n *\r\n * @param {object} options\r\n */\r\nfunction getQueryParser(options) {\r\n    var parse = parser(\"qs\");\r\n    var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;\r\n    if (isNaN(parameterLimit) || parameterLimit < 1) {\r\n        throw new TypeError(\"option parameterLimit must be a positive number\");\r\n    }\r\n    if (isFinite(parameterLimit)) {\r\n        parameterLimit = parameterLimit | 0;\r\n    }\r\n    return function queryparse(body) {\r\n        var paramCount = parameterCount(body, parameterLimit);\r\n        if (paramCount === undefined) {\r\n            debug(\"too many parameters\");\r\n            throw createError(413, \"too many parameters\", {\r\n                type: \"parameters.too.many\",\r\n            });\r\n        }\r\n        var arrayLimit = Math.max(100, paramCount);\r\n        debug(\"parse extended urlencoding\");\r\n        return parse(body, {\r\n            allowPrototypes: true,\r\n            arrayLimit: arrayLimit,\r\n            depth: Infinity,\r\n            parameterLimit: parameterLimit,\r\n        });\r\n    };\r\n}\r\n/**\r\n * Get the charset of a request.\r\n *\r\n * @param {object} req\r\n * @api private\r\n */\r\nfunction getCharset(req) {\r\n    try {\r\n        return (contentType.parse(req).parameters.charset || \"\").toLowerCase();\r\n    }\r\n    catch (e) {\r\n        return undefined;\r\n    }\r\n}\r\n/**\r\n * Count the number of parameters, stopping once limit reached\r\n *\r\n * @param {string} body\r\n * @param {number} limit\r\n * @api private\r\n */\r\nfunction parameterCount(body, limit) {\r\n    var count = 0;\r\n    var index = 0;\r\n    while ((index = body.indexOf(\"&\", index)) !== -1) {\r\n        count++;\r\n        index++;\r\n        if (count === limit) {\r\n            return undefined;\r\n        }\r\n    }\r\n    return count;\r\n}\r\n/**\r\n * Get parser for module name dynamically.\r\n *\r\n * @param {string} name\r\n * @return {function}\r\n * @api private\r\n */\r\nfunction parser(name) {\r\n    var mod = parsers[name];\r\n    if (mod !== undefined) {\r\n        return mod.parse;\r\n    }\r\n    // this uses a switch for static require analysis\r\n    switch (name) {\r\n        case \"qs\":\r\n            mod = require(\"qs\");\r\n            break;\r\n        case \"querystring\":\r\n            mod = require(\"querystring\");\r\n            break;\r\n    }\r\n    // store to prevent invoking require()\r\n    parsers[name] = mod;\r\n    return mod.parse;\r\n}\r\n//# sourceMappingURL=urlencoded.js.map"]}