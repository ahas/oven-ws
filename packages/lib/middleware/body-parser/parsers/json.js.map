{"version":3,"sources":["json.js"],"names":["bytes","contentType","createError","dbg","read","typeis","typeChecker","debug","FIRST_CHAR_REGEXP","json","options","opts","limit","parse","inflate","reviver","strict","type","verify","TypeError","shouldParse","body","length","first","firstchar","createStrictSyntaxError","JSON","e","normalizeJsonSyntaxError","message","stack","jsonParser","req","res","next","bodyParsed","hasBody","headers","charset","getCharset","substr","toUpperCase","encoding","str","char","index","indexOf","partial","substring","SyntaxError","replace","exec","parameters","toLowerCase","undefined","error","obj","keys","Object","getOwnPropertyNames","i","key"],"mappings":"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","file":"json.js","sourcesContent":["import bytes from \"bytes\";\r\nimport contentType from \"content-type\";\r\nimport createError from \"http-errors\";\r\nimport dbg from \"debug\";\r\nimport read from \"../read\";\r\nimport typeis from \"type-is\";\r\nimport { typeChecker } from \"src/utils\";\r\nvar debug = dbg(\"body-parser:json\");\r\n/**\r\n * RegExp to match the first non-space in a string.\r\n *\r\n * Allowed whitespace is defined in RFC 7159:\r\n *\r\n *    ws = *(\r\n *            %x20 /              ; Space\r\n *            %x09 /              ; Horizontal tab\r\n *            %x0A /              ; Line feed or New line\r\n *            %x0D )              ; Carriage return\r\n */\r\nvar FIRST_CHAR_REGEXP = /^[\\x20\\x09\\x0a\\x0d]*(.)/; // eslint-disable-line no-control-regex\r\n/**\r\n * Create a middleware to parse JSON bodies.\r\n *\r\n * @param {object} [options]\r\n * @return {function}\r\n * @public\r\n */\r\nexport default function json(options) {\r\n    var opts = options || {};\r\n    var limit = typeof opts.limit !== \"number\" ? bytes.parse(opts.limit || \"100kb\") : opts.limit;\r\n    var inflate = opts.inflate !== false;\r\n    var reviver = opts.reviver;\r\n    var strict = opts.strict !== false;\r\n    var type = opts.type || \"application/json\";\r\n    var verify = opts.verify || false;\r\n    if (verify !== false && typeof verify !== \"function\") {\r\n        throw new TypeError(\"option verify must be function\");\r\n    }\r\n    // create the appropriate type checking function\r\n    var shouldParse = typeof type !== \"function\" ? typeChecker(type) : type;\r\n    function parse(body) {\r\n        if (body.length === 0) {\r\n            // special-case empty json body, as it's a common client-side mistake\r\n            // TODO: maybe make this configurable or part of \"strict\" option\r\n            return {};\r\n        }\r\n        if (strict) {\r\n            var first = firstchar(body);\r\n            if (first !== \"{\" && first !== \"[\") {\r\n                debug(\"strict violation\");\r\n                throw createStrictSyntaxError(body, first);\r\n            }\r\n        }\r\n        try {\r\n            debug(\"parse json\");\r\n            return JSON.parse(body, reviver);\r\n        }\r\n        catch (e) {\r\n            throw normalizeJsonSyntaxError(e, {\r\n                message: e.message,\r\n                stack: e.stack,\r\n            });\r\n        }\r\n    }\r\n    return function jsonParser(req, res, next) {\r\n        if (req.bodyParsed) {\r\n            debug(\"body already parsed\");\r\n            next();\r\n            return;\r\n        }\r\n        req.body = req.body || {};\r\n        // skip requests without bodies\r\n        if (!typeis.hasBody(req)) {\r\n            debug(\"skip empty body\");\r\n            next();\r\n            return;\r\n        }\r\n        debug(\"content-type %j\", req.headers[\"content-type\"]);\r\n        // determine if request should be parsed\r\n        if (!shouldParse(req)) {\r\n            debug(\"skip parsing\");\r\n            next();\r\n            return;\r\n        }\r\n        // assert charset per RFC 7159 sec 8.1\r\n        var charset = getCharset(req) || \"utf-8\";\r\n        if (charset.substr(0, 4) !== \"utf-\") {\r\n            debug(\"invalid charset\");\r\n            next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\r\n                charset: charset,\r\n                type: \"charset.unsupported\",\r\n            }));\r\n            return;\r\n        }\r\n        // read\r\n        read(req, res, next, parse, debug, {\r\n            encoding: charset,\r\n            inflate: inflate,\r\n            limit: limit,\r\n            verify: verify,\r\n        });\r\n    };\r\n}\r\n/**\r\n * Create strict violation syntax error matching native error.\r\n *\r\n * @param {string} str\r\n * @param {string} char\r\n * @return {Error}\r\n * @private\r\n */\r\nfunction createStrictSyntaxError(str, char) {\r\n    var index = str.indexOf(char);\r\n    var partial = str.substring(0, index) + \"#\";\r\n    try {\r\n        JSON.parse(partial);\r\n        /* istanbul ignore next */ throw new SyntaxError(\"strict violation\");\r\n    }\r\n    catch (e) {\r\n        return normalizeJsonSyntaxError(e, {\r\n            message: e.message.replace(\"#\", char),\r\n            stack: e.stack,\r\n        });\r\n    }\r\n}\r\n/**\r\n * Get the first non-whitespace character in a string.\r\n *\r\n * @param {string} str\r\n * @return {function}\r\n * @private\r\n */\r\nfunction firstchar(str) {\r\n    return FIRST_CHAR_REGEXP.exec(str)[1];\r\n}\r\n/**\r\n * Get the charset of a request.\r\n *\r\n * @param {object} req\r\n * @api private\r\n */\r\nfunction getCharset(req) {\r\n    try {\r\n        return (contentType.parse(req).parameters.charset || \"\").toLowerCase();\r\n    }\r\n    catch (e) {\r\n        return undefined;\r\n    }\r\n}\r\n/**\r\n * Normalize a SyntaxError for JSON.parse.\r\n *\r\n * @param {SyntaxError} error\r\n * @param {object} obj\r\n * @return {SyntaxError}\r\n */\r\nfunction normalizeJsonSyntaxError(error, obj) {\r\n    var keys = Object.getOwnPropertyNames(error);\r\n    for (var i = 0; i < keys.length; i++) {\r\n        var key = keys[i];\r\n        if (key !== \"stack\" && key !== \"message\") {\r\n            delete error[key];\r\n        }\r\n    }\r\n    // replace stack before message for Node.js 0.10 and below\r\n    error.stack = obj.stack.replace(error.message, obj.message);\r\n    error.message = obj.message;\r\n    return error;\r\n}\r\n//# sourceMappingURL=json.js.map"]}