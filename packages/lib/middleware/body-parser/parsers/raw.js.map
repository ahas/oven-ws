{"version":3,"sources":["raw.js"],"names":["bytes","dbg","read","typeis","typeChecker","debug","raw","options","opts","inflate","limit","parse","type","verify","TypeError","shouldParse","buf","rawParser","req","res","next","bodyParsed","body","hasBody","headers","encoding"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,GAAP,MAAgB,OAAhB;AACA,OAAOC,IAAP,MAAiB,SAAjB;AACA,OAAOC,MAAP,MAAmB,SAAnB;AACA,SAASC,WAAT,QAA4B,WAA5B;AACA,IAAIC,QAAQJ,IAAI,iBAAJ,CAAZ;AACA;;;;;;;AAOA,eAAe,SAASK,GAAT,CAAaC,OAAb,EAAsB;AACjC,QAAIC,OAAOD,WAAW,EAAtB;AACA,QAAIE,UAAUD,KAAKC,OAAL,KAAiB,KAA/B;AACA,QAAIC,QAAQ,OAAOF,KAAKE,KAAZ,KAAsB,QAAtB,GAAiCV,MAAMW,KAAN,CAAYH,KAAKE,KAAL,IAAc,OAA1B,CAAjC,GAAsEF,KAAKE,KAAvF;AACA,QAAIE,OAAOJ,KAAKI,IAAL,IAAa,0BAAxB;AACA,QAAIC,SAASL,KAAKK,MAAL,IAAe,KAA5B;AACA,QAAIA,WAAW,KAAX,IAAoB,OAAOA,MAAP,KAAkB,UAA1C,EAAsD;AAClD,cAAM,IAAIC,SAAJ,CAAc,gCAAd,CAAN;AACH;AACD;AACA,QAAIC,cAAc,OAAOH,IAAP,KAAgB,UAAhB,GAA6BR,YAAYQ,IAAZ,CAA7B,GAAiDA,IAAnE;AACA,aAASD,KAAT,CAAeK,GAAf,EAAoB;AAChB,eAAOA,GAAP;AACH;AACD,WAAO,SAASC,SAAT,CAAmBC,GAAnB,EAAwBC,GAAxB,EAA6BC,IAA7B,EAAmC;AACtC,YAAIF,IAAIG,UAAR,EAAoB;AAChBhB,kBAAM,qBAAN;AACAe;AACA;AACH;AACDF,YAAII,IAAJ,GAAWJ,IAAII,IAAJ,IAAY,EAAvB;AACA;AACA,YAAI,CAACnB,OAAOoB,OAAP,CAAeL,GAAf,CAAL,EAA0B;AACtBb,kBAAM,iBAAN;AACAe;AACA;AACH;AACDf,cAAM,iBAAN,EAAyBa,IAAIM,OAAJ,CAAY,cAAZ,CAAzB;AACA;AACA,YAAI,CAACT,YAAYG,GAAZ,CAAL,EAAuB;AACnBb,kBAAM,cAAN;AACAe;AACA;AACH;AACD;AACAlB,aAAKgB,GAAL,EAAUC,GAAV,EAAeC,IAAf,EAAqBT,KAArB,EAA4BN,KAA5B,EAAmC;AAC/BoB,sBAAU,IADqB;AAE/BhB,qBAASA,OAFsB;AAG/BC,mBAAOA,KAHwB;AAI/BG,oBAAQA;AAJuB,SAAnC;AAMH,KA3BD;AA4BH;AACD","file":"raw.js","sourcesContent":["import bytes from \"bytes\";\r\nimport dbg from \"debug\";\r\nimport read from \"../read\";\r\nimport typeis from \"type-is\";\r\nimport { typeChecker } from \"src/utils\";\r\nvar debug = dbg(\"body-parser:raw\");\r\n/**\r\n * Create a middleware to parse raw bodies.\r\n *\r\n * @param {object} [options]\r\n * @return {function}\r\n * @api public\r\n */\r\nexport default function raw(options) {\r\n    var opts = options || {};\r\n    var inflate = opts.inflate !== false;\r\n    var limit = typeof opts.limit !== \"number\" ? bytes.parse(opts.limit || \"100kb\") : opts.limit;\r\n    var type = opts.type || \"application/octet-stream\";\r\n    var verify = opts.verify || false;\r\n    if (verify !== false && typeof verify !== \"function\") {\r\n        throw new TypeError(\"option verify must be function\");\r\n    }\r\n    // create the appropriate type checking function\r\n    var shouldParse = typeof type !== \"function\" ? typeChecker(type) : type;\r\n    function parse(buf) {\r\n        return buf;\r\n    }\r\n    return function rawParser(req, res, next) {\r\n        if (req.bodyParsed) {\r\n            debug(\"body already parsed\");\r\n            next();\r\n            return;\r\n        }\r\n        req.body = req.body || {};\r\n        // skip requests without bodies\r\n        if (!typeis.hasBody(req)) {\r\n            debug(\"skip empty body\");\r\n            next();\r\n            return;\r\n        }\r\n        debug(\"content-type %j\", req.headers[\"content-type\"]);\r\n        // determine if request should be parsed\r\n        if (!shouldParse(req)) {\r\n            debug(\"skip parsing\");\r\n            next();\r\n            return;\r\n        }\r\n        // read\r\n        read(req, res, next, parse, debug, {\r\n            encoding: null,\r\n            inflate: inflate,\r\n            limit: limit,\r\n            verify: verify,\r\n        });\r\n    };\r\n}\r\n//# sourceMappingURL=raw.js.map"]}