{"version":3,"sources":["utils.js"],"names":["Buffer","contentType","mime","etag","proxyaddr","qs","querystring","typeIs","createETagGenerator","options","generateETag","body","encoding","buf","isBuffer","from","etagGenerator","weak","wetagGenerator","wetag","isAbsolute","path","substring","normalizeType","type","indexOf","acceptParams","value","lookup","params","normalizeTypes","types","ret","i","length","push","str","index","parts","split","quality","originalIndex","pms","parseFloat","compileETag","val","fn","TypeError","compileQueryParser","parse","newObject","parseExtendedQueryString","compileTrust","_","addrs","compile","setCharset","charset","parsed","parameters","format","allowPrototypes","typeChecker","checkType","req","Boolean"],"mappings":"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","file":"utils.js","sourcesContent":["import { Buffer } from \"safe-buffer\";\r\nimport contentType from \"content-type\";\r\nimport { mime } from \"./send\";\r\nimport etag from \"etag\";\r\nimport proxyaddr from \"proxy-addr\";\r\nimport qs from \"qs\";\r\nimport querystring from \"querystring\";\r\nimport typeIs from \"type-is\";\r\n/**\r\n * Create an ETag generator function, generating ETags with\r\n * the given options.\r\n *\r\n * @param {object} options\r\n * @return {function}\r\n * @private\r\n */\r\nfunction createETagGenerator(options) {\r\n    return function generateETag(body, encoding) {\r\n        var buf = !Buffer.isBuffer(body) ? Buffer.from(body, encoding) : body;\r\n        return etag(buf, options);\r\n    };\r\n}\r\nvar etagGenerator = createETagGenerator({ weak: false });\r\nvar wetagGenerator = createETagGenerator({ weak: true });\r\n/**\r\n * Return strong ETag for `body`.\r\n *\r\n * @param {String|Buffer} body\r\n * @param {String} [encoding]\r\n * @return {String}\r\n * @api private\r\n */\r\nexport { etagGenerator as etag };\r\n/**\r\n * Return weak ETag for `body`.\r\n *\r\n * @param {String|Buffer} body\r\n * @param {String} [encoding]\r\n * @return {String}\r\n * @api private\r\n */\r\nexport { wetagGenerator as wetag };\r\n/**\r\n * Check if `path` looks absolute.\r\n *\r\n * @param {String} path\r\n * @return {Boolean}\r\n * @api private\r\n */\r\nexport function isAbsolute(path) {\r\n    if (\"/\" === path[0])\r\n        return true;\r\n    if (\":\" === path[1] && (\"\\\\\" === path[2] || \"/\" === path[2]))\r\n        return true; // Windows device path\r\n    if (\"\\\\\\\\\" === path.substring(0, 2))\r\n        return true; // Microsoft Azure absolute path\r\n}\r\n/**\r\n * Normalize the given `type`, for example \"html\" becomes \"text/html\".\r\n *\r\n * @param {String} type\r\n * @return {Object}\r\n * @api private\r\n */\r\nexport function normalizeType(type) {\r\n    return ~type.indexOf(\"/\") ? acceptParams(type) : { value: mime.lookup(type), params: {} };\r\n}\r\n/**\r\n * Normalize `types`, for example \"html\" becomes \"text/html\".\r\n *\r\n * @param {Array} types\r\n * @return {Array}\r\n * @api private\r\n */\r\nexport function normalizeTypes(types) {\r\n    var ret = [];\r\n    for (var i = 0; i < types.length; ++i) {\r\n        ret.push(normalizeType(types[i]));\r\n    }\r\n    return ret;\r\n}\r\n/**\r\n * Parse accept params `str` returning an\r\n * object with `.value`, `.quality` and `.params`.\r\n * also includes `.originalIndex` for stable sorting\r\n *\r\n * @param {String} str\r\n * @return {Object}\r\n * @api private\r\n */\r\nfunction acceptParams(str, index) {\r\n    var parts = str.split(/ *; */);\r\n    var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };\r\n    for (var i = 1; i < parts.length; ++i) {\r\n        var pms = parts[i].split(/ *= */);\r\n        if (\"q\" === pms[0]) {\r\n            ret.quality = parseFloat(pms[1]);\r\n        }\r\n        else {\r\n            ret.params[pms[0]] = pms[1];\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n/**\r\n * Compile \"etag\" value to function.\r\n *\r\n * @param  {Boolean|String|Function} val\r\n */\r\nexport function compileETag(val) {\r\n    var fn;\r\n    if (typeof val === \"function\") {\r\n        return val;\r\n    }\r\n    switch (val) {\r\n        case true:\r\n            fn = wetagGenerator;\r\n            break;\r\n        case false:\r\n            break;\r\n        case \"strong\":\r\n            fn = etagGenerator;\r\n            break;\r\n        case \"weak\":\r\n            fn = wetagGenerator;\r\n            break;\r\n        default:\r\n            throw new TypeError(\"unknown value for etag function: \" + val);\r\n    }\r\n    return fn;\r\n}\r\n/**\r\n * Compile \"query parser\" value to function.\r\n */\r\nexport function compileQueryParser(val) {\r\n    var fn;\r\n    if (typeof val === \"function\") {\r\n        return val;\r\n    }\r\n    switch (val) {\r\n        case true:\r\n            fn = querystring.parse;\r\n            break;\r\n        case false:\r\n            fn = newObject;\r\n            break;\r\n        case \"extended\":\r\n            fn = parseExtendedQueryString;\r\n            break;\r\n        case \"simple\":\r\n            fn = querystring.parse;\r\n            break;\r\n        default:\r\n            throw new TypeError(\"unknown value for query parser function: \" + val);\r\n    }\r\n    return fn;\r\n}\r\n/**\r\n * Compile \"proxy trust\" value to function.\r\n */\r\nexport function compileTrust(val) {\r\n    if (typeof val === \"function\") {\r\n        return val;\r\n    }\r\n    if (val === true) {\r\n        // Support plain true/false\r\n        return function () { return true; };\r\n    }\r\n    if (typeof val === \"number\") {\r\n        // Support trusting hop count\r\n        return function (_, i) { return i < val; };\r\n    }\r\n    // Support comma-separated values\r\n    var addrs = typeof val === \"string\" ? val.split(/ *, */) : [];\r\n    return proxyaddr.compile(addrs);\r\n}\r\n/**\r\n * Set the charset in a given Content-Type string.\r\n */\r\nexport function setCharset(type, charset) {\r\n    if (!type || !charset) {\r\n        return type;\r\n    }\r\n    // parse type\r\n    var parsed = contentType.parse(type);\r\n    // set charset\r\n    parsed.parameters.charset = charset;\r\n    // format type\r\n    return contentType.format(parsed);\r\n}\r\n/**\r\n * Parse an extended query string with qs.\r\n *\r\n * @return {Object}\r\n * @private\r\n */\r\nfunction parseExtendedQueryString(str) {\r\n    return qs.parse(str, {\r\n        allowPrototypes: true,\r\n    });\r\n}\r\n/**\r\n * Return new empty object.\r\n *\r\n * @return {Object}\r\n * @api private\r\n */\r\nfunction newObject() {\r\n    return {};\r\n}\r\n/**\r\n * Get the simple type checker.\r\n *\r\n * @param {string} type\r\n * @return {function}\r\n * @api public\r\n */\r\nexport function typeChecker(type) {\r\n    return function checkType(req) {\r\n        return Boolean(typeIs(req, type));\r\n    };\r\n}\r\n//# sourceMappingURL=utils.js.map"]}